<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Last Ent's Thoughts (Posts about scala)</title><link>https://last-ent.com/</link><description></description><atom:link href="https://last-ent.com/categories/scala.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents Â© 2019 &lt;a href="mailto:last_ent@outlook.com"&gt;Ent&lt;/a&gt; </copyright><lastBuildDate>Tue, 13 Aug 2019 07:41:16 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Cats Effect's IO</title><link>https://last-ent.com/posts/cats-effects-io/</link><dc:creator>Ent</dc:creator><description>&lt;div&gt;&lt;p&gt;Cats Effect's Fibers/IOs run on a thread pool created over VM. They are essentially Green Threads that are created over the thread pool. Unlike async frameworks, IO.flatmaps does not include _asynchronous boundary. This means that essentially all of nested flatmaps are run within a single fiber. IO has mechanism to introduce asynchronous boundary but this has to be done manually by the developer via IO.shift. Operations such as race, parMapN or parTraverse inherently introduce asynchronous boundary.&lt;/p&gt;
&lt;p&gt;~ 14th May, 22:11&lt;/p&gt;&lt;/div&gt;</description><category>programming</category><category>scala</category><guid>https://last-ent.com/posts/cats-effects-io/</guid><pubDate>Mon, 12 Aug 2019 18:44:38 GMT</pubDate></item></channel></rss>